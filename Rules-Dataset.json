[
    {
      "ID": "ISAVAILABLEINMDX_FALSE_NONATTRIBUTE_COLUMNS",
      "Name": "[Performance] Set IsAvailableInMdx to false on non-attribute columns",
      "Category": "Performance",
      "Description": "To speed up processing time and conserve memory after processing, attribute hierarchies should not be built for columns that are never used for slicing by MDX clients. In other words, all hidden columns that are not used as a Sort By Column or referenced in user hierarchies should have their IsAvailableInMdx property set to false.\r\nReference: https://blog.crossjoin.co.uk/2018/07/02/isavailableinmdx-ssas-tabular/",
      "Severity": 2,
      "Scope": "DataColumn, CalculatedColumn, CalculatedTableColumn",
      "Expression": "IsAvailableInMDX\r\nand\r\n\n(IsHidden or Table.IsHidden)\r\nand\r\n\nnot UsedInSortBy.Any() \r\nand\r\n\nnot UsedInHierarchies.Any()\r\nand\r\nnot UsedInVariations.Any()\r\nand\r\nSortByColumn = null",
      "FixExpression": "IsAvailableInMDX = false",
      "CompatibilityLevel": 1200
    },
    {
      "ID": "AVOID_BI-DIRECTIONAL_RELATIONSHIPS_AGAINST_HIGH-CARDINALITY_COLUMNS",
      "Name": "[Performance] Avoid bi-directional relationships against high-cardinality columns",
      "Category": "Performance",
      "Description": "For best performance, it is recommended to avoid using bi-directional relationships against high-cardinality columns. In order to run this rule, you must first run the script shown here: https://www.elegantbi.com/post/vertipaqintabulareditor",
      "Severity": 2,
      "Scope": "DataColumn, CalculatedColumn, CalculatedTableColumn",
      "Expression": "UsedInRelationships.Any(CrossFilteringBehavior == CrossFilteringBehavior.BothDirections)\n\nand\n\nConvert.ToInt64(GetAnnotation(\"Vertipaq_Cardinality\")) > 100000",
      "CompatibilityLevel": 1200
    },
    {
      "ID": "REDUCE_USAGE_OF_LONG-LENGTH_COLUMNS_WITH_HIGH_CARDINALITY",
      "Name": "[Performance] Reduce usage of long-length columns with high cardinality",
      "Category": "Performance",
      "Description": "It is best to avoid lengthy text columns. This is especially true if the column has many unique values. These types of columns can cause longer processing times, bloated model sizes, as well as slower user queries. Long length is defined as more than 100 characters.",
      "Severity": 2,
      "Scope": "DataColumn, CalculatedColumn, CalculatedTableColumn",
      "Expression": "Convert.ToInt64(GetAnnotation(\"LongLengthRowCount\")) > 500000",
      "CompatibilityLevel": 1200
    },
    {
      "ID": "SPLIT_DATE_AND_TIME",
      "Name": "[Performance] Split date and time",
      "Category": "Performance",
      "Description": "This rule finds datetime columns that have values not at midnight. To maximize performance, the time element should be split from date element (or the time component should be rounded to midnight as this will reduce column cardinality).\r\nReference: https://www.sqlbi.com/articles/separate-date-and-time-in-powerpivot-and-bism-tabular/",
      "Severity": 2,
      "Scope": "DataColumn, CalculatedColumn, CalculatedTableColumn",
      "Expression": "Convert.ToInt32(GetAnnotation(\"DateTimeWithHourMinSec\")) > 0",
      "CompatibilityLevel": 1200
    },
    {
      "ID": "LARGE_TABLES_SHOULD_BE_PARTITIONED",
      "Name": "[Performance] Large tables should be partitioned",
      "Category": "Performance",
      "Description": "Large tables should be partitioned in order to optimize processing. In order for this rule to run properly, you must run the script shown here: https://www.elegantbi.com/post/vertipaqintabulareditor",
      "Severity": 2,
      "Scope": "Table",
      "Expression": "Convert.ToInt64(GetAnnotation(\"Vertipaq_RowCount\")) > 25000000\r\nand\r\nPartitions.Count = 1",
      "CompatibilityLevel": 1200
    },
    {
      "ID": "REDUCE_USAGE_OF_CALCULATED_COLUMNS_THAT_USE_THE_RELATED_FUNCTION",
      "Name": "[Performance] Reduce usage of calculated columns that use the RELATED function",
      "Category": "Performance",
      "Description": "Calculated columns do not compress as well as data columns and may cause longer processing times. As such, calculated columns should be avoided if possible. One scenario where they may be easier to avoid is if they use the RELATED function.\r\nReference: https://www.sqlbi.com/articles/storage-differences-between-calculated-columns-and-calculated-tables/",
      "Severity": 2,
      "Scope": "CalculatedColumn",
      "Expression": "RegEx.IsMatch(Expression,\"(?i)RELATED\\s*\\(\")",
      "CompatibilityLevel": 1200
    },
	{
      "ID": "AVOID_FLOATING_POINT_DATA_TYPES",
      "Name": "[Performance] Do not use floating point data types",
      "Category": "Performance",
      "Description": "The \"Double\" floating point data type should be avoided, as it can result in unpredictable roundoff errors and decreased performance in certain scenarios. Use \"Int64\" or \"Decimal\" where appropriate (but note that \"Decimal\" is limited to 4 digits after the decimal sign).",
      "Severity": 3,
      "Scope": "DataColumn, CalculatedColumn, CalculatedTableColumn",
      "Expression": "DataType = \"Double\"",
      "FixExpression": "DataType = DataType.Decimal",
      "CompatibilityLevel": 1200
    },
    {
      "ID": "SNOWFLAKE_SCHEMA_ARCHITECTURE",
      "Name": "[Performance] Consider a star-schema instead of a snowflake architecture",
      "Category": "Performance",
      "Description": "Generally speaking, a star-schema is the optimal architecture for tabular models. That being the case, there are valid cases to use a snowflake approach. Please check your model and consider moving to a star-schema architecture.\r\nReference: https://docs.microsoft.com/power-bi/guidance/star-schema",
      "Severity": 2,
      "Scope": "Table, CalculatedTable",
      "Expression": "UsedInRelationships.Any(current.Name == FromTable.Name)\r\nand\r\nUsedInRelationships.Any(current.Name == ToTable.Name)",
      "CompatibilityLevel": 1200
    }
  ]